@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.MutableList<T>.shuffle(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") public fun </*0*/ T> kotlin.collections.MutableList<T>.shuffle(/*0*/ random: kotlin.random.Random): kotlin.Unit
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.shuffled(): kotlin.collections.List<T>
@kotlin.SinceKotlin(version = "1.3") public fun </*0*/ T> kotlin.collections.Iterable<T>.shuffled(/*0*/ random: kotlin.random.Random): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.single(): T
public inline fun </*0*/ T> kotlin.Array<out T>.single(/*0*/ predicate: (T) -> kotlin.Boolean): T
public fun kotlin.BooleanArray.single(): kotlin.Boolean
public inline fun kotlin.BooleanArray.single(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean
public fun kotlin.ByteArray.single(): kotlin.Byte
public inline fun kotlin.ByteArray.single(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.Byte
public fun kotlin.CharArray.single(): kotlin.Char
public inline fun kotlin.CharArray.single(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Char
public fun kotlin.DoubleArray.single(): kotlin.Double
public inline fun kotlin.DoubleArray.single(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.Double
public fun kotlin.FloatArray.single(): kotlin.Float
public inline fun kotlin.FloatArray.single(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.Float
public fun kotlin.IntArray.single(): kotlin.Int
public inline fun kotlin.IntArray.single(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.Int
public fun kotlin.LongArray.single(): kotlin.Long
public inline fun kotlin.LongArray.single(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.Long
public fun kotlin.ShortArray.single(): kotlin.Short
public inline fun kotlin.ShortArray.single(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.Short
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.single(): kotlin.UByte
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.single(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.UByte
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.single(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.single(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.single(): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.single(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.single(): kotlin.UShort
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.single(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.UShort
public fun </*0*/ T> kotlin.collections.Iterable<T>.single(): T
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.single(/*0*/ predicate: (T) -> kotlin.Boolean): T
public fun </*0*/ T> kotlin.collections.List<T>.single(): T
public fun </*0*/ T> kotlin.Array<out T>.singleOrNull(): T?
public inline fun </*0*/ T> kotlin.Array<out T>.singleOrNull(/*0*/ predicate: (T) -> kotlin.Boolean): T?
public fun kotlin.BooleanArray.singleOrNull(): kotlin.Boolean?
public inline fun kotlin.BooleanArray.singleOrNull(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.Boolean?
public fun kotlin.ByteArray.singleOrNull(): kotlin.Byte?
public inline fun kotlin.ByteArray.singleOrNull(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.Byte?
public fun kotlin.CharArray.singleOrNull(): kotlin.Char?
public inline fun kotlin.CharArray.singleOrNull(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Char?
public fun kotlin.DoubleArray.singleOrNull(): kotlin.Double?
public inline fun kotlin.DoubleArray.singleOrNull(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.Double?
public fun kotlin.FloatArray.singleOrNull(): kotlin.Float?
public inline fun kotlin.FloatArray.singleOrNull(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.Float?
public fun kotlin.IntArray.singleOrNull(): kotlin.Int?
public inline fun kotlin.IntArray.singleOrNull(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.Int?
public fun kotlin.LongArray.singleOrNull(): kotlin.Long?
public inline fun kotlin.LongArray.singleOrNull(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.Long?
public fun kotlin.ShortArray.singleOrNull(): kotlin.Short?
public inline fun kotlin.ShortArray.singleOrNull(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.Short?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.singleOrNull(): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.singleOrNull(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.UByte?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.singleOrNull(): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.singleOrNull(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.UInt?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.singleOrNull(): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.singleOrNull(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.ULong?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.singleOrNull(): kotlin.UShort?
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.singleOrNull(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.UShort?
public fun </*0*/ T> kotlin.collections.Iterable<T>.singleOrNull(): T?
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.singleOrNull(/*0*/ predicate: (T) -> kotlin.Boolean): T?
public fun </*0*/ T> kotlin.collections.List<T>.singleOrNull(): T?
public fun </*0*/ T> kotlin.Array<out T>.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<T>
public fun kotlin.BooleanArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.BooleanArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Byte>
public fun kotlin.ByteArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Char>
public fun kotlin.CharArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Double>
public fun kotlin.DoubleArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Float>
public fun kotlin.FloatArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Int>
public fun kotlin.IntArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Long>
public fun kotlin.LongArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.Short>
public fun kotlin.ShortArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<kotlin.UShort>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.List<T>.slice(/*0*/ indices: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.collections.List<T>.slice(/*0*/ indices: kotlin.ranges.IntRange): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<T>.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.Array<T>
public fun </*0*/ T> kotlin.Array<T>.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.Array<T>
public fun kotlin.BooleanArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.BooleanArray
public fun kotlin.BooleanArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.BooleanArray
public fun kotlin.ByteArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ByteArray
public fun kotlin.ByteArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ByteArray
public fun kotlin.CharArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.CharArray
public fun kotlin.CharArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.CharArray
public fun kotlin.DoubleArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.DoubleArray
public fun kotlin.DoubleArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.DoubleArray
public fun kotlin.FloatArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.FloatArray
public fun kotlin.FloatArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.FloatArray
public fun kotlin.IntArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.IntArray
public fun kotlin.IntArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.IntArray
public fun kotlin.LongArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.LongArray
public fun kotlin.LongArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.LongArray
public fun kotlin.ShortArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ShortArray
public fun kotlin.ShortArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sliceArray(/*0*/ indices: kotlin.collections.Collection<kotlin.Int>): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sliceArray(/*0*/ indices: kotlin.ranges.IntRange): kotlin.UShortArray
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sort(): kotlin.Unit
public fun </*0*/ T> kotlin.Array<out T>.sort(/*0*/ comparison: (a: T, b: T) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.ByteArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.sort(/*0*/ noinline comparison: (a: kotlin.Byte, b: kotlin.Byte) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.CharArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.CharArray.sort(/*0*/ noinline comparison: (a: kotlin.Char, b: kotlin.Char) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.DoubleArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.DoubleArray.sort(/*0*/ noinline comparison: (a: kotlin.Double, b: kotlin.Double) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.FloatArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.FloatArray.sort(/*0*/ noinline comparison: (a: kotlin.Float, b: kotlin.Float) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.IntArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.IntArray.sort(/*0*/ noinline comparison: (a: kotlin.Int, b: kotlin.Int) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.LongArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.LongArray.sort(/*0*/ noinline comparison: (a: kotlin.Long, b: kotlin.Long) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun kotlin.ShortArray.sort(): kotlin.Unit
@kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.sort(/*0*/ noinline comparison: (a: kotlin.Short, b: kotlin.Short) -> kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sort(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sort(/*0*/ fromIndex: kotlin.Int = ..., /*1*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sort(): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortBy(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortBy(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ByteArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ByteArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.CharArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.CharArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.DoubleArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.DoubleArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.FloatArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.FloatArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.IntArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.IntArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.LongArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.LongArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun kotlin.ShortArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun kotlin.ShortArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortDescending(): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortDescending(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.MutableList<T>.sortDescending(): kotlin.Unit
public fun </*0*/ T> kotlin.Array<out T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Unit
@kotlin.SinceKotlin(version = "1.4") public fun </*0*/ T> kotlin.Array<out T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>, /*1*/ fromIndex: kotlin.Int = ..., /*2*/ toIndex: kotlin.Int = ...): kotlin.Unit
public fun </*0*/ T> kotlin.collections.MutableList<T>.sortWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Unit
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sorted(): kotlin.collections.List<T>
public fun kotlin.ByteArray.sorted(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sorted(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sorted(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sorted(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sorted(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sorted(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sorted(): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sorted(): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sorted(): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sorted(): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sorted(): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sorted(): kotlin.collections.List<T>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<T>.sortedArray(): kotlin.Array<T>
public fun kotlin.ByteArray.sortedArray(): kotlin.ByteArray
public fun kotlin.CharArray.sortedArray(): kotlin.CharArray
public fun kotlin.DoubleArray.sortedArray(): kotlin.DoubleArray
public fun kotlin.FloatArray.sortedArray(): kotlin.FloatArray
public fun kotlin.IntArray.sortedArray(): kotlin.IntArray
public fun kotlin.LongArray.sortedArray(): kotlin.LongArray
public fun kotlin.ShortArray.sortedArray(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedArray(): kotlin.UShortArray
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<T>.sortedArrayDescending(): kotlin.Array<T>
public fun kotlin.ByteArray.sortedArrayDescending(): kotlin.ByteArray
public fun kotlin.CharArray.sortedArrayDescending(): kotlin.CharArray
public fun kotlin.DoubleArray.sortedArrayDescending(): kotlin.DoubleArray
public fun kotlin.FloatArray.sortedArrayDescending(): kotlin.FloatArray
public fun kotlin.IntArray.sortedArrayDescending(): kotlin.IntArray
public fun kotlin.LongArray.sortedArrayDescending(): kotlin.LongArray
public fun kotlin.ShortArray.sortedArrayDescending(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedArrayDescending(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedArrayDescending(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedArrayDescending(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedArrayDescending(): kotlin.UShortArray
public fun </*0*/ T> kotlin.Array<out T>.sortedArrayWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.Array<out T>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortedBy(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.BooleanArray.sortedBy(/*0*/ crossinline selector: (kotlin.Boolean) -> R?): kotlin.collections.List<kotlin.Boolean>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ByteArray.sortedBy(/*0*/ crossinline selector: (kotlin.Byte) -> R?): kotlin.collections.List<kotlin.Byte>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.CharArray.sortedBy(/*0*/ crossinline selector: (kotlin.Char) -> R?): kotlin.collections.List<kotlin.Char>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.DoubleArray.sortedBy(/*0*/ crossinline selector: (kotlin.Double) -> R?): kotlin.collections.List<kotlin.Double>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.FloatArray.sortedBy(/*0*/ crossinline selector: (kotlin.Float) -> R?): kotlin.collections.List<kotlin.Float>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.IntArray.sortedBy(/*0*/ crossinline selector: (kotlin.Int) -> R?): kotlin.collections.List<kotlin.Int>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.LongArray.sortedBy(/*0*/ crossinline selector: (kotlin.Long) -> R?): kotlin.collections.List<kotlin.Long>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ShortArray.sortedBy(/*0*/ crossinline selector: (kotlin.Short) -> R?): kotlin.collections.List<kotlin.Short>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedBy(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.Array<out T>.sortedByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.BooleanArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Boolean) -> R?): kotlin.collections.List<kotlin.Boolean>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ByteArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Byte) -> R?): kotlin.collections.List<kotlin.Byte>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.CharArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Char) -> R?): kotlin.collections.List<kotlin.Char>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.DoubleArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Double) -> R?): kotlin.collections.List<kotlin.Double>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.FloatArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Float) -> R?): kotlin.collections.List<kotlin.Float>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.IntArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Int) -> R?): kotlin.collections.List<kotlin.Int>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.LongArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Long) -> R?): kotlin.collections.List<kotlin.Long>
public inline fun </*0*/ R : kotlin.Comparable<R>> kotlin.ShortArray.sortedByDescending(/*0*/ crossinline selector: (kotlin.Short) -> R?): kotlin.collections.List<kotlin.Short>
public inline fun </*0*/ T, /*1*/ R : kotlin.Comparable<R>> kotlin.collections.Iterable<T>.sortedByDescending(/*0*/ crossinline selector: (T) -> R?): kotlin.collections.List<T>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.Array<out T>.sortedDescending(): kotlin.collections.List<T>
public fun kotlin.ByteArray.sortedDescending(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sortedDescending(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sortedDescending(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sortedDescending(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sortedDescending(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sortedDescending(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sortedDescending(): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.sortedDescending(): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.sortedDescending(): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.sortedDescending(): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.sortedDescending(): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.sortedDescending(): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.sortedWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.collections.List<T>
public fun kotlin.BooleanArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Boolean>): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Byte>): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Char>): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Double>): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Float>): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Int>): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Long>): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.sortedWith(/*0*/ comparator: kotlin.Comparator<in kotlin.Short>): kotlin.collections.List<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.sortedWith(/*0*/ comparator: kotlin.Comparator<in T>): kotlin.collections.List<T>
public infix fun </*0*/ T> kotlin.Array<out T>.subtract(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public infix fun kotlin.BooleanArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Boolean>): kotlin.collections.Set<kotlin.Boolean>
public infix fun kotlin.ByteArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Byte>): kotlin.collections.Set<kotlin.Byte>
public infix fun kotlin.CharArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Char>): kotlin.collections.Set<kotlin.Char>
public infix fun kotlin.DoubleArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Double>): kotlin.collections.Set<kotlin.Double>
public infix fun kotlin.FloatArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Float>): kotlin.collections.Set<kotlin.Float>
public infix fun kotlin.IntArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.Set<kotlin.Int>
public infix fun kotlin.LongArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Long>): kotlin.collections.Set<kotlin.Long>
public infix fun kotlin.ShortArray.subtract(/*0*/ other: kotlin.collections.Iterable<kotlin.Short>): kotlin.collections.Set<kotlin.Short>
public infix fun </*0*/ T> kotlin.collections.Iterable<T>.subtract(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
@kotlin.jvm.JvmName(name = "sumOfByte") public fun kotlin.Array<out kotlin.Byte>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfDouble") public fun kotlin.Array<out kotlin.Double>.sum(): kotlin.Double
@kotlin.jvm.JvmName(name = "sumOfFloat") public fun kotlin.Array<out kotlin.Float>.sum(): kotlin.Float
@kotlin.jvm.JvmName(name = "sumOfInt") public fun kotlin.Array<out kotlin.Int>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfLong") public fun kotlin.Array<out kotlin.Long>.sum(): kotlin.Long
@kotlin.jvm.JvmName(name = "sumOfShort") public fun kotlin.Array<out kotlin.Short>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfUByte") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UByte>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UInt>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.ULong>.sum(): kotlin.ULong
@kotlin.jvm.JvmName(name = "sumOfUShort") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UShort>.sum(): kotlin.UInt
public fun kotlin.ByteArray.sum(): kotlin.Int
public fun kotlin.DoubleArray.sum(): kotlin.Double
public fun kotlin.FloatArray.sum(): kotlin.Float
public fun kotlin.IntArray.sum(): kotlin.Int
public fun kotlin.LongArray.sum(): kotlin.Long
public fun kotlin.ShortArray.sum(): kotlin.Int
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sum(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sum(): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sum(): kotlin.ULong
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfByte") public fun kotlin.collections.Iterable<kotlin.Byte>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfDouble") public fun kotlin.collections.Iterable<kotlin.Double>.sum(): kotlin.Double
@kotlin.jvm.JvmName(name = "sumOfFloat") public fun kotlin.collections.Iterable<kotlin.Float>.sum(): kotlin.Float
@kotlin.jvm.JvmName(name = "sumOfInt") public fun kotlin.collections.Iterable<kotlin.Int>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfLong") public fun kotlin.collections.Iterable<kotlin.Long>.sum(): kotlin.Long
@kotlin.jvm.JvmName(name = "sumOfShort") public fun kotlin.collections.Iterable<kotlin.Short>.sum(): kotlin.Int
@kotlin.jvm.JvmName(name = "sumOfUByte") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UByte>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfUInt") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UInt>.sum(): kotlin.UInt
@kotlin.jvm.JvmName(name = "sumOfULong") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.ULong>.sum(): kotlin.ULong
@kotlin.jvm.JvmName(name = "sumOfUShort") @kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Iterable<kotlin.UShort>.sum(): kotlin.UInt
public inline fun </*0*/ T> kotlin.Array<out T>.sumBy(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
public inline fun kotlin.BooleanArray.sumBy(/*0*/ selector: (kotlin.Boolean) -> kotlin.Int): kotlin.Int
public inline fun kotlin.ByteArray.sumBy(/*0*/ selector: (kotlin.Byte) -> kotlin.Int): kotlin.Int
public inline fun kotlin.CharArray.sumBy(/*0*/ selector: (kotlin.Char) -> kotlin.Int): kotlin.Int
public inline fun kotlin.DoubleArray.sumBy(/*0*/ selector: (kotlin.Double) -> kotlin.Int): kotlin.Int
public inline fun kotlin.FloatArray.sumBy(/*0*/ selector: (kotlin.Float) -> kotlin.Int): kotlin.Int
public inline fun kotlin.IntArray.sumBy(/*0*/ selector: (kotlin.Int) -> kotlin.Int): kotlin.Int
public inline fun kotlin.LongArray.sumBy(/*0*/ selector: (kotlin.Long) -> kotlin.Int): kotlin.Int
public inline fun kotlin.ShortArray.sumBy(/*0*/ selector: (kotlin.Short) -> kotlin.Int): kotlin.Int
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumBy(/*0*/ selector: (kotlin.UByte) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumBy(/*0*/ selector: (kotlin.UInt) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumBy(/*0*/ selector: (kotlin.ULong) -> kotlin.UInt): kotlin.UInt
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumBy(/*0*/ selector: (kotlin.UShort) -> kotlin.UInt): kotlin.UInt
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumBy(/*0*/ selector: (T) -> kotlin.Int): kotlin.Int
public inline fun </*0*/ T> kotlin.Array<out T>.sumByDouble(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
public inline fun kotlin.BooleanArray.sumByDouble(/*0*/ selector: (kotlin.Boolean) -> kotlin.Double): kotlin.Double
public inline fun kotlin.ByteArray.sumByDouble(/*0*/ selector: (kotlin.Byte) -> kotlin.Double): kotlin.Double
public inline fun kotlin.CharArray.sumByDouble(/*0*/ selector: (kotlin.Char) -> kotlin.Double): kotlin.Double
public inline fun kotlin.DoubleArray.sumByDouble(/*0*/ selector: (kotlin.Double) -> kotlin.Double): kotlin.Double
public inline fun kotlin.FloatArray.sumByDouble(/*0*/ selector: (kotlin.Float) -> kotlin.Double): kotlin.Double
public inline fun kotlin.IntArray.sumByDouble(/*0*/ selector: (kotlin.Int) -> kotlin.Double): kotlin.Double
public inline fun kotlin.LongArray.sumByDouble(/*0*/ selector: (kotlin.Long) -> kotlin.Double): kotlin.Double
public inline fun kotlin.ShortArray.sumByDouble(/*0*/ selector: (kotlin.Short) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.sumByDouble(/*0*/ selector: (kotlin.UByte) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.sumByDouble(/*0*/ selector: (kotlin.UInt) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.sumByDouble(/*0*/ selector: (kotlin.ULong) -> kotlin.Double): kotlin.Double
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.sumByDouble(/*0*/ selector: (kotlin.UShort) -> kotlin.Double): kotlin.Double
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.sumByDouble(/*0*/ selector: (T) -> kotlin.Double): kotlin.Double
public fun </*0*/ T> kotlin.Array<out T>.take(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun kotlin.BooleanArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.take(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.Iterable<T>.take(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun </*0*/ T> kotlin.Array<out T>.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public fun kotlin.BooleanArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<kotlin.UShort>
public fun </*0*/ T> kotlin.collections.List<T>.takeLast(/*0*/ n: kotlin.Int): kotlin.collections.List<T>
public inline fun </*0*/ T> kotlin.Array<out T>.takeLastWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun kotlin.BooleanArray.takeLastWhile(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
public inline fun kotlin.ByteArray.takeLastWhile(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.collections.List<kotlin.Byte>
public inline fun kotlin.CharArray.takeLastWhile(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.collections.List<kotlin.Char>
public inline fun kotlin.DoubleArray.takeLastWhile(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.collections.List<kotlin.Double>
public inline fun kotlin.FloatArray.takeLastWhile(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.collections.List<kotlin.Float>
public inline fun kotlin.IntArray.takeLastWhile(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.collections.List<kotlin.Int>
public inline fun kotlin.LongArray.takeLastWhile(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.collections.List<kotlin.Long>
public inline fun kotlin.ShortArray.takeLastWhile(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.takeLastWhile(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.takeLastWhile(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.takeLastWhile(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.takeLastWhile(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.collections.List<kotlin.UShort>
public inline fun </*0*/ T> kotlin.collections.List<T>.takeLastWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun </*0*/ T> kotlin.Array<out T>.takeWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public inline fun kotlin.BooleanArray.takeWhile(/*0*/ predicate: (kotlin.Boolean) -> kotlin.Boolean): kotlin.collections.List<kotlin.Boolean>
public inline fun kotlin.ByteArray.takeWhile(/*0*/ predicate: (kotlin.Byte) -> kotlin.Boolean): kotlin.collections.List<kotlin.Byte>
public inline fun kotlin.CharArray.takeWhile(/*0*/ predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.collections.List<kotlin.Char>
public inline fun kotlin.DoubleArray.takeWhile(/*0*/ predicate: (kotlin.Double) -> kotlin.Boolean): kotlin.collections.List<kotlin.Double>
public inline fun kotlin.FloatArray.takeWhile(/*0*/ predicate: (kotlin.Float) -> kotlin.Boolean): kotlin.collections.List<kotlin.Float>
public inline fun kotlin.IntArray.takeWhile(/*0*/ predicate: (kotlin.Int) -> kotlin.Boolean): kotlin.collections.List<kotlin.Int>
public inline fun kotlin.LongArray.takeWhile(/*0*/ predicate: (kotlin.Long) -> kotlin.Boolean): kotlin.collections.List<kotlin.Long>
public inline fun kotlin.ShortArray.takeWhile(/*0*/ predicate: (kotlin.Short) -> kotlin.Boolean): kotlin.collections.List<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.takeWhile(/*0*/ predicate: (kotlin.UByte) -> kotlin.Boolean): kotlin.collections.List<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.takeWhile(/*0*/ predicate: (kotlin.UInt) -> kotlin.Boolean): kotlin.collections.List<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.takeWhile(/*0*/ predicate: (kotlin.ULong) -> kotlin.Boolean): kotlin.collections.List<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.takeWhile(/*0*/ predicate: (kotlin.UShort) -> kotlin.Boolean): kotlin.collections.List<kotlin.UShort>
public inline fun </*0*/ T> kotlin.collections.Iterable<T>.takeWhile(/*0*/ predicate: (T) -> kotlin.Boolean): kotlin.collections.List<T>
public fun kotlin.Array<out kotlin.Boolean>.toBooleanArray(): kotlin.BooleanArray
public fun kotlin.collections.Collection<kotlin.Boolean>.toBooleanArray(): kotlin.BooleanArray
public fun kotlin.Array<out kotlin.Byte>.toByteArray(): kotlin.ByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UByteArray.toByteArray(): kotlin.ByteArray
public fun kotlin.collections.Collection<kotlin.Byte>.toByteArray(): kotlin.ByteArray
public fun kotlin.Array<out kotlin.Char>.toCharArray(): kotlin.CharArray
public fun kotlin.collections.Collection<kotlin.Char>.toCharArray(): kotlin.CharArray
public fun </*0*/ T, /*1*/ C : kotlin.collections.MutableCollection<in T>> kotlin.Array<out T>.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Boolean>> kotlin.BooleanArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Byte>> kotlin.ByteArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Char>> kotlin.CharArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Double>> kotlin.DoubleArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Float>> kotlin.FloatArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Int>> kotlin.IntArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Long>> kotlin.LongArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ C : kotlin.collections.MutableCollection<in kotlin.Short>> kotlin.ShortArray.toCollection(/*0*/ destination: C): C
public fun </*0*/ T, /*1*/ C : kotlin.collections.MutableCollection<in T>> kotlin.collections.Iterable<T>.toCollection(/*0*/ destination: C): C
public fun kotlin.Array<out kotlin.Double>.toDoubleArray(): kotlin.DoubleArray
public fun kotlin.collections.Collection<kotlin.Double>.toDoubleArray(): kotlin.DoubleArray
public fun kotlin.Array<out kotlin.Float>.toFloatArray(): kotlin.FloatArray
public fun kotlin.collections.Collection<kotlin.Float>.toFloatArray(): kotlin.FloatArray
public fun </*0*/ T> kotlin.Array<out T>.toHashSet(): kotlin.collections.HashSet<T>
public fun kotlin.BooleanArray.toHashSet(): kotlin.collections.HashSet<kotlin.Boolean>
public fun kotlin.ByteArray.toHashSet(): kotlin.collections.HashSet<kotlin.Byte>
public fun kotlin.CharArray.toHashSet(): kotlin.collections.HashSet<kotlin.Char>
public fun kotlin.DoubleArray.toHashSet(): kotlin.collections.HashSet<kotlin.Double>
public fun kotlin.FloatArray.toHashSet(): kotlin.collections.HashSet<kotlin.Float>
public fun kotlin.IntArray.toHashSet(): kotlin.collections.HashSet<kotlin.Int>
public fun kotlin.LongArray.toHashSet(): kotlin.collections.HashSet<kotlin.Long>
public fun kotlin.ShortArray.toHashSet(): kotlin.collections.HashSet<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toHashSet(): kotlin.collections.HashSet<T>
public fun kotlin.Array<out kotlin.Int>.toIntArray(): kotlin.IntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UIntArray.toIntArray(): kotlin.IntArray
public fun kotlin.collections.Collection<kotlin.Int>.toIntArray(): kotlin.IntArray
public fun </*0*/ T> kotlin.Array<out T>.toList(): kotlin.collections.List<T>
public fun kotlin.BooleanArray.toList(): kotlin.collections.List<kotlin.Boolean>
public fun kotlin.ByteArray.toList(): kotlin.collections.List<kotlin.Byte>
public fun kotlin.CharArray.toList(): kotlin.collections.List<kotlin.Char>
public fun kotlin.DoubleArray.toList(): kotlin.collections.List<kotlin.Double>
public fun kotlin.FloatArray.toList(): kotlin.collections.List<kotlin.Float>
public fun kotlin.IntArray.toList(): kotlin.collections.List<kotlin.Int>
public fun kotlin.LongArray.toList(): kotlin.collections.List<kotlin.Long>
public fun kotlin.ShortArray.toList(): kotlin.collections.List<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toList(): kotlin.collections.List<T>
public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toList(): kotlin.collections.List<kotlin.Pair<K, V>>
public fun kotlin.Array<out kotlin.Long>.toLongArray(): kotlin.LongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ULongArray.toLongArray(): kotlin.LongArray
public fun kotlin.collections.Collection<kotlin.Long>.toLongArray(): kotlin.LongArray
public fun </*0*/ K, /*1*/ V> kotlin.Array<out kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.Array<out kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
public fun </*0*/ K, /*1*/ V> kotlin.collections.Iterable<kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Iterable<kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toMap(): kotlin.collections.Map<K, V>
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.collections.Map<out K, V>.toMap(/*0*/ destination: M): M
public fun </*0*/ K, /*1*/ V> kotlin.sequences.Sequence<kotlin.Pair<K, V>>.toMap(): kotlin.collections.Map<K, V>
public fun </*0*/ K, /*1*/ V, /*2*/ M : kotlin.collections.MutableMap<in K, in V>> kotlin.sequences.Sequence<kotlin.Pair<K, V>>.toMap(/*0*/ destination: M): M
public fun </*0*/ T> kotlin.Array<out T>.toMutableList(): kotlin.collections.MutableList<T>
public fun kotlin.BooleanArray.toMutableList(): kotlin.collections.MutableList<kotlin.Boolean>
public fun kotlin.ByteArray.toMutableList(): kotlin.collections.MutableList<kotlin.Byte>
public fun kotlin.CharArray.toMutableList(): kotlin.collections.MutableList<kotlin.Char>
public fun kotlin.DoubleArray.toMutableList(): kotlin.collections.MutableList<kotlin.Double>
public fun kotlin.FloatArray.toMutableList(): kotlin.collections.MutableList<kotlin.Float>
public fun kotlin.IntArray.toMutableList(): kotlin.collections.MutableList<kotlin.Int>
public fun kotlin.LongArray.toMutableList(): kotlin.collections.MutableList<kotlin.Long>
public fun kotlin.ShortArray.toMutableList(): kotlin.collections.MutableList<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Collection<T>.toMutableList(): kotlin.collections.MutableList<T>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toMutableList(): kotlin.collections.MutableList<T>
@kotlin.SinceKotlin(version = "1.1") public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<out K, V>.toMutableMap(): kotlin.collections.MutableMap<K, V>
public fun </*0*/ T> kotlin.Array<out T>.toMutableSet(): kotlin.collections.MutableSet<T>
public fun kotlin.BooleanArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Boolean>
public fun kotlin.ByteArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Byte>
public fun kotlin.CharArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Char>
public fun kotlin.DoubleArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Double>
public fun kotlin.FloatArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Float>
public fun kotlin.IntArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Int>
public fun kotlin.LongArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Long>
public fun kotlin.ShortArray.toMutableSet(): kotlin.collections.MutableSet<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toMutableSet(): kotlin.collections.MutableSet<T>
@kotlin.internal.InlineOnly public inline fun </*0*/ K, /*1*/ V> kotlin.collections.Map.Entry<K, V>.toPair(): kotlin.Pair<K, V>
public fun </*0*/ T> kotlin.Array<out T>.toSet(): kotlin.collections.Set<T>
public fun kotlin.BooleanArray.toSet(): kotlin.collections.Set<kotlin.Boolean>
public fun kotlin.ByteArray.toSet(): kotlin.collections.Set<kotlin.Byte>
public fun kotlin.CharArray.toSet(): kotlin.collections.Set<kotlin.Char>
public fun kotlin.DoubleArray.toSet(): kotlin.collections.Set<kotlin.Double>
public fun kotlin.FloatArray.toSet(): kotlin.collections.Set<kotlin.Float>
public fun kotlin.IntArray.toSet(): kotlin.collections.Set<kotlin.Int>
public fun kotlin.LongArray.toSet(): kotlin.collections.Set<kotlin.Long>
public fun kotlin.ShortArray.toSet(): kotlin.collections.Set<kotlin.Short>
public fun </*0*/ T> kotlin.collections.Iterable<T>.toSet(): kotlin.collections.Set<T>
public fun kotlin.Array<out kotlin.Short>.toShortArray(): kotlin.ShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UShortArray.toShortArray(): kotlin.ShortArray
public fun kotlin.collections.Collection<kotlin.Short>.toShortArray(): kotlin.ShortArray
public fun kotlin.BooleanArray.toTypedArray(): kotlin.Array<kotlin.Boolean>
public fun kotlin.ByteArray.toTypedArray(): kotlin.Array<kotlin.Byte>
public fun kotlin.CharArray.toTypedArray(): kotlin.Array<kotlin.Char>
public fun kotlin.DoubleArray.toTypedArray(): kotlin.Array<kotlin.Double>
public fun kotlin.FloatArray.toTypedArray(): kotlin.Array<kotlin.Float>
public fun kotlin.IntArray.toTypedArray(): kotlin.Array<kotlin.Int>
public fun kotlin.LongArray.toTypedArray(): kotlin.Array<kotlin.Long>
public fun kotlin.ShortArray.toTypedArray(): kotlin.Array<kotlin.Short>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.toTypedArray(): kotlin.Array<kotlin.UByte>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.toTypedArray(): kotlin.Array<kotlin.UInt>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.toTypedArray(): kotlin.Array<kotlin.ULong>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.toTypedArray(): kotlin.Array<kotlin.UShort>
@kotlin.internal.InlineOnly public inline fun </*0*/ T> kotlin.collections.Collection<T>.toTypedArray(): kotlin.Array<T>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UByte>.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ByteArray.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UByte>.toUByteArray(): kotlin.UByteArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UInt>.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.IntArray.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UInt>.toUIntArray(): kotlin.UIntArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.ULong>.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.LongArray.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.ULong>.toULongArray(): kotlin.ULongArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.Array<out kotlin.UShort>.toUShortArray(): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.ShortArray.toUShortArray(): kotlin.UShortArray
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.collections.Collection<kotlin.UShort>.toUShortArray(): kotlin.UShortArray
public infix fun </*0*/ T> kotlin.Array<out T>.union(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public infix fun kotlin.BooleanArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Boolean>): kotlin.collections.Set<kotlin.Boolean>
public infix fun kotlin.ByteArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Byte>): kotlin.collections.Set<kotlin.Byte>
public infix fun kotlin.CharArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Char>): kotlin.collections.Set<kotlin.Char>
public infix fun kotlin.DoubleArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Double>): kotlin.collections.Set<kotlin.Double>
public infix fun kotlin.FloatArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Float>): kotlin.collections.Set<kotlin.Float>
public infix fun kotlin.IntArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Int>): kotlin.collections.Set<kotlin.Int>
public infix fun kotlin.LongArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Long>): kotlin.collections.Set<kotlin.Long>
public infix fun kotlin.ShortArray.union(/*0*/ other: kotlin.collections.Iterable<kotlin.Short>): kotlin.collections.Set<kotlin.Short>
public infix fun </*0*/ T> kotlin.collections.Iterable<T>.union(/*0*/ other: kotlin.collections.Iterable<T>): kotlin.collections.Set<T>
public fun </*0*/ T, /*1*/ R> kotlin.Array<out kotlin.Pair<T, R>>.unzip(): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<R>>
public fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<kotlin.Pair<T, R>>.unzip(): kotlin.Pair<kotlin.collections.List<T>, kotlin.collections.List<R>>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.windowed(/*0*/ size: kotlin.Int, /*1*/ step: kotlin.Int = ..., /*2*/ partialWindows: kotlin.Boolean = ...): kotlin.collections.List<kotlin.collections.List<T>>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.windowed(/*0*/ size: kotlin.Int, /*1*/ step: kotlin.Int = ..., /*2*/ partialWindows: kotlin.Boolean = ..., /*3*/ transform: (kotlin.collections.List<T>) -> R): kotlin.collections.List<R>
public fun </*0*/ K, /*1*/ V> kotlin.collections.Map<K, V>.withDefault(/*0*/ defaultValue: (key: K) -> V): kotlin.collections.Map<K, V>
@kotlin.jvm.JvmName(name = "withDefaultMutable") public fun </*0*/ K, /*1*/ V> kotlin.collections.MutableMap<K, V>.withDefault(/*0*/ defaultValue: (key: K) -> V): kotlin.collections.MutableMap<K, V>
public fun </*0*/ T> kotlin.Array<out T>.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<T>>
public fun kotlin.BooleanArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Boolean>>
public fun kotlin.ByteArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Byte>>
public fun kotlin.CharArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Char>>
public fun kotlin.DoubleArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Double>>
public fun kotlin.FloatArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Float>>
public fun kotlin.IntArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Int>>
public fun kotlin.LongArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Long>>
public fun kotlin.ShortArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.Short>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByteArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UByte>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UIntArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UInt>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.ULongArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.ULong>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShortArray.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<kotlin.UShort>>
public fun </*0*/ T> kotlin.collections.Iterable<T>.withIndex(): kotlin.collections.Iterable<kotlin.collections.IndexedValue<T>>
public fun </*0*/ T> kotlin.collections.Iterator<T>.withIndex(): kotlin.collections.Iterator<kotlin.collections.IndexedValue<T>>
public infix fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.Array<out T>.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.Array<out T>.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.Array<out T>.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.BooleanArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Boolean, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.BooleanArray.zip(/*0*/ other: kotlin.BooleanArray): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, kotlin.Boolean>>
public inline fun </*0*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.BooleanArray, /*1*/ transform: (a: kotlin.Boolean, b: kotlin.Boolean) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.BooleanArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Boolean, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.BooleanArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Boolean, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ByteArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Byte, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Byte, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.ByteArray.zip(/*0*/ other: kotlin.ByteArray): kotlin.collections.List<kotlin.Pair<kotlin.Byte, kotlin.Byte>>
public inline fun </*0*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.ByteArray, /*1*/ transform: (a: kotlin.Byte, b: kotlin.Byte) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Byte, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Byte, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.CharArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Char, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Char, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.CharArray.zip(/*0*/ other: kotlin.CharArray): kotlin.collections.List<kotlin.Pair<kotlin.Char, kotlin.Char>>
public inline fun </*0*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.CharArray, /*1*/ transform: (a: kotlin.Char, b: kotlin.Char) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.CharArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Char, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.CharArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Char, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.DoubleArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Double, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Double, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.DoubleArray.zip(/*0*/ other: kotlin.DoubleArray): kotlin.collections.List<kotlin.Pair<kotlin.Double, kotlin.Double>>
public inline fun </*0*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.DoubleArray, /*1*/ transform: (a: kotlin.Double, b: kotlin.Double) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.DoubleArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Double, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.DoubleArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Double, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.FloatArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Float, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Float, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.FloatArray.zip(/*0*/ other: kotlin.FloatArray): kotlin.collections.List<kotlin.Pair<kotlin.Float, kotlin.Float>>
public inline fun </*0*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.FloatArray, /*1*/ transform: (a: kotlin.Float, b: kotlin.Float) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.FloatArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Float, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.FloatArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Float, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.IntArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Int, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Int, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.IntArray.zip(/*0*/ other: kotlin.IntArray): kotlin.collections.List<kotlin.Pair<kotlin.Int, kotlin.Int>>
public inline fun </*0*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.IntArray, /*1*/ transform: (a: kotlin.Int, b: kotlin.Int) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.IntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Int, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.IntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Int, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.LongArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Long, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Long, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.LongArray.zip(/*0*/ other: kotlin.LongArray): kotlin.collections.List<kotlin.Pair<kotlin.Long, kotlin.Long>>
public inline fun </*0*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.LongArray, /*1*/ transform: (a: kotlin.Long, b: kotlin.Long) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.LongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Long, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.LongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Long, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ShortArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.Short, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.Short, b: R) -> V): kotlin.collections.List<V>
public infix fun kotlin.ShortArray.zip(/*0*/ other: kotlin.ShortArray): kotlin.collections.List<kotlin.Pair<kotlin.Short, kotlin.Short>>
public inline fun </*0*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.ShortArray, /*1*/ transform: (a: kotlin.Short, b: kotlin.Short) -> V): kotlin.collections.List<V>
public infix fun </*0*/ R> kotlin.ShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.Short, R>>
public inline fun </*0*/ R, /*1*/ V> kotlin.ShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.Short, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UByteArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UByte, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UByte, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UByteArray.zip(/*0*/ other: kotlin.UByteArray): kotlin.collections.List<kotlin.Pair<kotlin.UByte, kotlin.UByte>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.UByteArray, /*1*/ transform: (a: kotlin.UByte, b: kotlin.UByte) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UByte, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UByteArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UByte, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UIntArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UInt, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UInt, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UIntArray.zip(/*0*/ other: kotlin.UIntArray): kotlin.collections.List<kotlin.Pair<kotlin.UInt, kotlin.UInt>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.UIntArray, /*1*/ transform: (a: kotlin.UInt, b: kotlin.UInt) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UIntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UInt, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UIntArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UInt, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.ULongArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.ULong, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.ULong, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.ULongArray.zip(/*0*/ other: kotlin.ULongArray): kotlin.collections.List<kotlin.Pair<kotlin.ULong, kotlin.ULong>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.ULongArray, /*1*/ transform: (a: kotlin.ULong, b: kotlin.ULong) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.ULongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.ULong, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.ULongArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.ULong, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UShortArray.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<kotlin.UShort, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun kotlin.UShortArray.zip(/*0*/ other: kotlin.UShortArray): kotlin.collections.List<kotlin.Pair<kotlin.UShort, kotlin.UShort>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.UShortArray, /*1*/ transform: (a: kotlin.UShort, b: kotlin.UShort) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes public infix fun </*0*/ R> kotlin.UShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UShort, R>>
@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun </*0*/ R, /*1*/ V> kotlin.UShortArray.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.Array<out R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
public infix fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>>
public inline fun </*0*/ T, /*1*/ R, /*2*/ V> kotlin.collections.Iterable<T>.zip(/*0*/ other: kotlin.collections.Iterable<R>, /*1*/ transform: (a: T, b: R) -> V): kotlin.collections.List<V>
@kotlin.SinceKotlin(version = "1.2") public fun </*0*/ T> kotlin.collections.Iterable<T>.zipWithNext(): kotlin.collections.List<kotlin.Pair<T, T>>
@kotlin.SinceKotlin(version = "1.2") public inline fun </*0*/ T, /*1*/ R> kotlin.collections.Iterable<T>.zipWithNext(/*0*/ transform: (a: T, b: T) -> R): kotlin.collections.List<R>

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractCollection</*0*/ out E> : kotlin.collections.Collection<E> {
    /*primary*/ protected constructor AbstractCollection</*0*/ out E>()
    public abstract override /*1*/ val size: kotlin.Int
        public abstract override /*1*/ fun <get-size>(): kotlin.Int
    public open override /*1*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun containsAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.collections.Iterator<E>
    @kotlin.js.JsName(name = "toArray") protected open fun toArray(): kotlin.Array<kotlin.Any?>
    protected open fun </*0*/ T> toArray(/*0*/ array: kotlin.Array<T>): kotlin.Array<T>
    public open override /*1*/ fun toString(): kotlin.String
}

public abstract class AbstractIterator</*0*/ T> : kotlin.collections.Iterator<T> {
    /*primary*/ public constructor AbstractIterator</*0*/ T>()
    protected abstract fun computeNext(): kotlin.Unit
    protected final fun done(): kotlin.Unit
    public open override /*1*/ fun hasNext(): kotlin.Boolean
    public open override /*1*/ fun next(): T
    protected final fun setNext(/*0*/ value: T): kotlin.Unit
}

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractList</*0*/ out E> : kotlin.collections.AbstractCollection<E>, kotlin.collections.List<E> {
    /*primary*/ protected constructor AbstractList</*0*/ out E>()
    public abstract override /*2*/ val size: kotlin.Int
        public abstract override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public abstract override /*1*/ fun get(/*0*/ index: kotlin.Int): E
    public open override /*2*/ fun hashCode(): kotlin.Int
    public open override /*1*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public open override /*2*/ fun iterator(): kotlin.collections.Iterator<E>
    public open override /*1*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public open override /*1*/ fun listIterator(): kotlin.collections.ListIterator<E>
    public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.collections.ListIterator<E>
    public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.collections.List<E>
}

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractMap</*0*/ K, /*1*/ out V> : kotlin.collections.Map<K, V> {
    /*primary*/ protected constructor AbstractMap</*0*/ K, /*1*/ out V>()
    public open override /*1*/ val keys: kotlin.collections.Set<K>
        public open override /*1*/ fun <get-keys>(): kotlin.collections.Set<K>
    public open override /*1*/ val size: kotlin.Int
        public open override /*1*/ fun <get-size>(): kotlin.Int
    public open override /*1*/ val values: kotlin.collections.Collection<V>
        public open override /*1*/ fun <get-values>(): kotlin.collections.Collection<V>
    public open override /*1*/ fun containsKey(/*0*/ key: K): kotlin.Boolean
    public open override /*1*/ fun containsValue(/*0*/ value: V): kotlin.Boolean
    public open override /*1*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ fun get(/*0*/ key: K): V?
    public open override /*1*/ fun hashCode(): kotlin.Int
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public open override /*1*/ fun toString(): kotlin.String
}

public abstract class AbstractMutableCollection</*0*/ E> : kotlin.collections.AbstractCollection<E>, kotlin.collections.MutableCollection<E> {
    /*primary*/ protected constructor AbstractMutableCollection</*0*/ E>()
    public abstract override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun clear(): kotlin.Unit
    public open override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    @kotlin.js.JsName(name = "toJSON") public open fun toJSON(): kotlin.Any
}

public abstract class AbstractMutableList</*0*/ E> : kotlin.collections.AbstractMutableCollection<E>, kotlin.collections.MutableList<E> {
    /*primary*/ protected constructor AbstractMutableList</*0*/ E>()
    protected final var modCount: kotlin.Int
        protected final fun <get-modCount>(): kotlin.Int
        protected final fun <set-modCount>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*2*/ fun add(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*2*/ fun clear(): kotlin.Unit
    public open override /*2*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public open override /*2*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*2*/ fun hashCode(): kotlin.Int
    public open override /*1*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public open override /*2*/ fun iterator(): kotlin.collections.MutableIterator<E>
    public open override /*1*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public open override /*1*/ fun listIterator(): kotlin.collections.MutableListIterator<E>
    public open override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.collections.MutableListIterator<E>
    public open override /*2*/ fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun removeAt(/*0*/ index: kotlin.Int): E
    protected open fun removeRange(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
    public open override /*2*/ fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    public open override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.collections.MutableList<E>
}

public abstract class AbstractMutableMap</*0*/ K, /*1*/ V> : kotlin.collections.AbstractMap<K, V>, kotlin.collections.MutableMap<K, V> {
    /*primary*/ protected constructor AbstractMutableMap</*0*/ K, /*1*/ V>()
    public open override /*2*/ val keys: kotlin.collections.MutableSet<K>
        public open override /*2*/ fun <get-keys>(): kotlin.collections.MutableSet<K>
    public open override /*2*/ val values: kotlin.collections.MutableCollection<V>
        public open override /*2*/ fun <get-values>(): kotlin.collections.MutableCollection<V>
    public open override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*1*/ fun put(/*0*/ key: K, /*1*/ value: V): V?
    public open override /*1*/ fun putAll(/*0*/ from: kotlin.collections.Map<out K, V>): kotlin.Unit
    public open override /*1*/ fun remove(/*0*/ key: K): V?
}

public abstract class AbstractMutableSet</*0*/ E> : kotlin.collections.AbstractMutableCollection<E>, kotlin.collections.MutableSet<E> {
    /*primary*/ protected constructor AbstractMutableSet</*0*/ E>()
    public open override /*2*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*2*/ fun hashCode(): kotlin.Int
}

@kotlin.SinceKotlin(version = "1.1") public abstract class AbstractSet</*0*/ out E> : kotlin.collections.AbstractCollection<E>, kotlin.collections.Set<E> {
    /*primary*/ protected constructor AbstractSet</*0*/ out E>()
    public open override /*2*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*2*/ fun hashCode(): kotlin.Int
}

@kotlin.SinceKotlin(version = "1.3") @kotlin.ExperimentalStdlibApi public final class ArrayDeque</*0*/ E> : kotlin.collections.AbstractMutableList<E> {
    public constructor ArrayDeque</*0*/ E>()
    public constructor ArrayDeque</*0*/ E>(/*0*/ initialCapacity: kotlin.Int)
    public constructor ArrayDeque</*0*/ E>(/*0*/ elements: kotlin.collections.Collection<E>)
    public open override /*1*/ var size: kotlin.Int
        public open override /*1*/ fun <get-size>(): kotlin.Int
        private open fun <set-size>(/*0*/ <set-?>: kotlin.Int): kotlin.Unit
    public open override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public open override /*1*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public final fun addFirst(/*0*/ element: E): kotlin.Unit
    public final fun addLast(/*0*/ element: E): kotlin.Unit
    public open override /*1*/ fun clear(): kotlin.Unit
    public open override /*1*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public final fun first(): E
    public final fun firstOrNull(): E?
    public open override /*1*/ fun get(/*0*/ index: kotlin.Int): E
    public open override /*1*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public open override /*1*/ fun isEmpty(): kotlin.Boolean
    public final fun last(): E
    public open override /*1*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public final fun lastOrNull(): E?
    public open override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public open override /*1*/ fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun removeAt(/*0*/ index: kotlin.Int): E
    public final fun removeFirst(): E
    public final fun removeFirstOrNull(): E?
    public final fun removeLast(): E
    public final fun removeLastOrNull(): E?
    public open override /*1*/ fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*1*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
}

public open class ArrayList</*0*/ E> : kotlin.collections.AbstractMutableList<E>, kotlin.collections.MutableList<E>, kotlin.collections.RandomAccess {
    public constructor ArrayList</*0*/ E>()
    public constructor ArrayList</*0*/ E>(/*0*/ initialCapacity: kotlin.Int = ...)
    public constructor ArrayList</*0*/ E>(/*0*/ elements: kotlin.collections.Collection<E>)
    public open override /*2*/ val size: kotlin.Int
        public open override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun add(/*0*/ element: E): kotlin.Boolean
    public open override /*2*/ fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public open override /*2*/ fun addAll(/*0*/ index: kotlin.Int, /*1*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*2*/ fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public open override /*2*/ fun clear(): kotlin.Unit
    public final fun ensureCapacity(/*0*/ minCapacity: kotlin.Int): kotlin.Unit
    public open override /*2*/ fun get(/*0*/ index: kotlin.Int): E
    public open override /*2*/ fun indexOf(/*0*/ element: E): kotlin.Int
    public open override /*2*/ fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public open override /*2*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public open override /*2*/ fun removeAt(/*0*/ index: kotlin.Int): E
    protected open override /*1*/ fun removeRange(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.Unit
    public open override /*2*/ fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    protected open override /*1*/ fun toArray(): kotlin.Array<kotlin.Any?>
    public open override /*3*/ fun toString(): kotlin.String
    public final fun trimToSize(): kotlin.Unit
}

public abstract class BooleanIterator : kotlin.collections.Iterator<kotlin.Boolean> {
    /*primary*/ public constructor BooleanIterator()
    public final override /*1*/ fun next(): kotlin.Boolean
    public abstract fun nextBoolean(): kotlin.Boolean
}

public abstract class ByteIterator : kotlin.collections.Iterator<kotlin.Byte> {
    /*primary*/ public constructor ByteIterator()
    public final override /*1*/ fun next(): kotlin.Byte
    public abstract fun nextByte(): kotlin.Byte
}

public abstract class CharIterator : kotlin.collections.Iterator<kotlin.Char> {
    /*primary*/ public constructor CharIterator()
    public final override /*1*/ fun next(): kotlin.Char
    public abstract fun nextChar(): kotlin.Char
}

public interface Collection</*0*/ out E> : kotlin.collections.Iterable<E> {
    public abstract val size: kotlin.Int
        public abstract fun <get-size>(): kotlin.Int
    public abstract operator fun contains(/*0*/ element: E): kotlin.Boolean
    public abstract fun containsAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.collections.Iterator<E>
}

public abstract class DoubleIterator : kotlin.collections.Iterator<kotlin.Double> {
    /*primary*/ public constructor DoubleIterator()
    public final override /*1*/ fun next(): kotlin.Double
    public abstract fun nextDouble(): kotlin.Double
}

public abstract class FloatIterator : kotlin.collections.Iterator<kotlin.Float> {
    /*primary*/ public constructor FloatIterator()
    public final override /*1*/ fun next(): kotlin.Float
    public abstract fun nextFloat(): kotlin.Float
}

@kotlin.SinceKotlin(version = "1.1") public interface Grouping</*0*/ T, /*1*/ out K> {
    public abstract fun keyOf(/*0*/ element: T): K
    public abstract fun sourceIterator(): kotlin.collections.Iterator<T>
}

public open class HashMap</*0*/ K, /*1*/ V> : kotlin.collections.AbstractMutableMap<K, V>, kotlin.collections.MutableMap<K, V> {
    public constructor HashMap</*0*/ K, /*1*/ V>()
    public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ initialCapacity: kotlin.Int)
    public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ initialCapacity: kotlin.Int, /*1*/ loadFactor: kotlin.Float = ...)
    public constructor HashMap</*0*/ K, /*1*/ V>(/*0*/ original: kotlin.collections.Map<out K, V>)
    public open override /*2*/ val entries: kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<K, V>>
        public open override /*2*/ fun <get-entries>(): kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<K, V>>
    public open override /*2*/ val size: kotlin.Int
        public open override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun clear(): kotlin.Unit
    public open override /*2*/ fun containsKey(/*0*/ key: K): kotlin.Boolean
    public open override /*2*/ fun containsValue(/*0*/ value: V): kotlin.Boolean
    protected open fun createEntrySet(): kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<K, V>>
    public open override /*2*/ fun get(/*0*/ key: K): V?
    public open override /*2*/ fun put(/*0*/ key: K, /*1*/ value: V): V?
    public open override /*2*/ fun remove(/*0*/ key: K): V?
}

public open class HashSet</*0*/ E> : kotlin.collections.AbstractMutableSet<E>, kotlin.collections.MutableSet<E> {
    public constructor HashSet</*0*/ E>()
    public constructor HashSet</*0*/ E>(/*0*/ initialCapacity: kotlin.Int)
    public constructor HashSet</*0*/ E>(/*0*/ initialCapacity: kotlin.Int, /*1*/ loadFactor: kotlin.Float = ...)
    public constructor HashSet</*0*/ E>(/*0*/ elements: kotlin.collections.Collection<E>)
    public open override /*2*/ val size: kotlin.Int
        public open override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun add(/*0*/ element: E): kotlin.Boolean
    public open override /*2*/ fun clear(): kotlin.Unit
    public open override /*2*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public open override /*2*/ fun isEmpty(): kotlin.Boolean
    public open override /*2*/ fun iterator(): kotlin.collections.MutableIterator<E>
    public open override /*2*/ fun remove(/*0*/ element: E): kotlin.Boolean
}

public final data class IndexedValue</*0*/ out T> {
    /*primary*/ public constructor IndexedValue</*0*/ out T>(/*0*/ index: kotlin.Int, /*1*/ value: T)
    public final val index: kotlin.Int
        public final fun <get-index>(): kotlin.Int
    public final val value: T
        public final fun <get-value>(): T
    public final operator /*synthesized*/ fun component1(): kotlin.Int
    public final operator /*synthesized*/ fun component2(): T
    public final /*synthesized*/ fun copy(/*0*/ index: kotlin.Int = ..., /*1*/ value: T = ...): kotlin.collections.IndexedValue<T>
    public open override /*1*/ /*synthesized*/ fun equals(/*0*/ other: kotlin.Any?): kotlin.Boolean
    public open override /*1*/ /*synthesized*/ fun hashCode(): kotlin.Int
    public open override /*1*/ /*synthesized*/ fun toString(): kotlin.String
}

public abstract class IntIterator : kotlin.collections.Iterator<kotlin.Int> {
    /*primary*/ public constructor IntIterator()
    public final override /*1*/ fun next(): kotlin.Int
    public abstract fun nextInt(): kotlin.Int
}

public interface Iterable</*0*/ out T> {
    public abstract operator fun iterator(): kotlin.collections.Iterator<T>
}

public interface Iterator</*0*/ out T> {
    public abstract operator fun hasNext(): kotlin.Boolean
    public abstract operator fun next(): T
}

public open class LinkedHashMap</*0*/ K, /*1*/ V> : kotlin.collections.HashMap<K, V>, kotlin.collections.MutableMap<K, V> {
    public constructor LinkedHashMap</*0*/ K, /*1*/ V>()
    public constructor LinkedHashMap</*0*/ K, /*1*/ V>(/*0*/ initialCapacity: kotlin.Int)
    public constructor LinkedHashMap</*0*/ K, /*1*/ V>(/*0*/ initialCapacity: kotlin.Int, /*1*/ loadFactor: kotlin.Float = ...)
    public constructor LinkedHashMap</*0*/ K, /*1*/ V>(/*0*/ original: kotlin.collections.Map<out K, V>)
    public open override /*2*/ val size: kotlin.Int
        public open override /*2*/ fun <get-size>(): kotlin.Int
    public open override /*2*/ fun clear(): kotlin.Unit
    public open override /*2*/ fun containsKey(/*0*/ key: K): kotlin.Boolean
    public open override /*2*/ fun containsValue(/*0*/ value: V): kotlin.Boolean
    protected open override /*1*/ fun createEntrySet(): kotlin.collections.MutableSet<kotlin.collections.MutableMap.MutableEntry<K, V>>
    public open override /*2*/ fun get(/*0*/ key: K): V?
    public open override /*2*/ fun put(/*0*/ key: K, /*1*/ value: V): V?
    public open override /*2*/ fun remove(/*0*/ key: K): V?
}

public open class LinkedHashSet</*0*/ E> : kotlin.collections.HashSet<E>, kotlin.collections.MutableSet<E> {
    public constructor LinkedHashSet</*0*/ E>()
    public constructor LinkedHashSet</*0*/ E>(/*0*/ initialCapacity: kotlin.Int)
    public constructor LinkedHashSet</*0*/ E>(/*0*/ initialCapacity: kotlin.Int, /*1*/ loadFactor: kotlin.Float = ...)
    public constructor LinkedHashSet</*0*/ E>(/*0*/ elements: kotlin.collections.Collection<E>)
}

public interface List</*0*/ out E> : kotlin.collections.Collection<E> {
    public abstract override /*1*/ val size: kotlin.Int
        public abstract override /*1*/ fun <get-size>(): kotlin.Int
    public abstract override /*1*/ fun contains(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun containsAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract operator fun get(/*0*/ index: kotlin.Int): E
    public abstract fun indexOf(/*0*/ element: E): kotlin.Int
    public abstract override /*1*/ fun isEmpty(): kotlin.Boolean
    public abstract override /*1*/ fun iterator(): kotlin.collections.Iterator<E>
    public abstract fun lastIndexOf(/*0*/ element: E): kotlin.Int
    public abstract fun listIterator(): kotlin.collections.ListIterator<E>
    public abstract fun listIterator(/*0*/ index: kotlin.Int): kotlin.collections.ListIterator<E>
    public abstract fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.collections.List<E>
}

public interface ListIterator</*0*/ out T> : kotlin.collections.Iterator<T> {
    public abstract override /*1*/ fun hasNext(): kotlin.Boolean
    public abstract fun hasPrevious(): kotlin.Boolean
    public abstract override /*1*/ fun next(): T
    public abstract fun nextIndex(): kotlin.Int
    public abstract fun previous(): T
    public abstract fun previousIndex(): kotlin.Int
}

public abstract class LongIterator : kotlin.collections.Iterator<kotlin.Long> {
    /*primary*/ public constructor LongIterator()
    public final override /*1*/ fun next(): kotlin.Long
    public abstract fun nextLong(): kotlin.Long
}

public interface Map</*0*/ K, /*1*/ out V> {
    public abstract val entries: kotlin.collections.Set<kotlin.collections.Map.Entry<K, V>>
        public abstract fun <get-entries>(): kotlin.collections.Set<kotlin.collections.Map.Entry<K, V>>
    public abstract val keys: kotlin.collections.Set<K>
        public abstract fun <get-keys>(): kotlin.collections.Set<K>
    public abstract val size: kotlin.Int
        public abstract fun <get-size>(): kotlin.Int
    public abstract val values: kotlin.collections.Collection<V>
        public abstract fun <get-values>(): kotlin.collections.Collection<V>
    public abstract fun containsKey(/*0*/ key: K): kotlin.Boolean
    public abstract fun containsValue(/*0*/ value: V): kotlin.Boolean
    public abstract operator fun get(/*0*/ key: K): V?
    public abstract fun isEmpty(): kotlin.Boolean

    public interface Entry</*0*/ out K, /*1*/ out V> {
        public abstract val key: K
            public abstract fun <get-key>(): K
        public abstract val value: V
            public abstract fun <get-value>(): V
    }
}

public interface MutableCollection</*0*/ E> : kotlin.collections.Collection<E>, kotlin.collections.MutableIterable<E> {
    public abstract fun add(/*0*/ element: E): kotlin.Boolean
    public abstract fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract fun clear(): kotlin.Unit
    public abstract override /*2*/ fun iterator(): kotlin.collections.MutableIterator<E>
    public abstract fun remove(/*0*/ element: E): kotlin.Boolean
    public abstract fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
}

public interface MutableIterable</*0*/ out T> : kotlin.collections.Iterable<T> {
    public abstract override /*1*/ fun iterator(): kotlin.collections.MutableIterator<T>
}

public interface MutableIterator</*0*/ out T> : kotlin.collections.Iterator<T> {
    public abstract fun remove(): kotlin.Unit
}

public interface MutableList</*0*/ E> : kotlin.collections.List<E>, kotlin.collections.MutableCollection<E> {
    public abstract override /*1*/ fun add(/*0*/ element: E): kotlin.Boolean
    public abstract fun add(/*0*/ index: kotlin.Int, /*1*/ element: E): kotlin.Unit
    public abstract fun addAll(/*0*/ index: kotlin.Int, /*1*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun addAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract override /*1*/ fun clear(): kotlin.Unit
    public abstract override /*1*/ fun listIterator(): kotlin.collections.MutableListIterator<E>
    public abstract override /*1*/ fun listIterator(/*0*/ index: kotlin.Int): kotlin.collections.MutableListIterator<E>
    public abstract override /*1*/ fun remove(/*0*/ element: E): kotlin.Boolean
    public abstract override /*1*/ fun removeAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract fun removeAt(/*0*/ index: kotlin.Int): E
    public abstract override /*1*/ fun retainAll(/*0*/ elements: kotlin.collections.Collection<E>): kotlin.Boolean
    public abstract operator fun set(/*0*/ index: kotlin.Int, /*1*/ element: E): E
    public abstract override /*1*/ fun subList(/*0*/ fromIndex: kotlin.Int, /*1*/ toIndex: kotlin.Int): kotlin.collections.MutableList<E>
}
